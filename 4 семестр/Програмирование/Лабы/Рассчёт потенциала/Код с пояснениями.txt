using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;


namespace Рассчёт_потенциала
{
    class Program
    {
        public static void Main(string[] args) {
            //Типы данных:
            //double - число с точкой(вещественное)
            //int - целое число, отрицательное положительное или ноль
            //массив - несколько чиселзаданного типа, к которым можно обращаться по номерам.
            //двухмерный массив эквивалентен матрице, трехмерный - нескольким матрицам одинаковых размерностей(как бы в несколько слоёв)
        
            //Начальные значения массива Ft - везде 0, а по краям F0
            double F0 = 5;
            // размеры области значений x и y, для которых вычисляются значения Ft
            double xl = 100, yl = 100; 
            //Размер одной ячейки сетки, отображаемой Gnuplot'ом
            int dx = 5, dy = 5;
            // nx и ny это размеры сетки, в виде которой будут отрисовываться значения Ft
            // вычисляются как размер области делённый на размер одной ячейки сетки(dx и dy соответственно). Нужно для Gnuplot
            int nx = (int)xl / dx, ny = (int)yl / dy;
            // Ft - трехмерный массив вещественных чисел(double) размерности [nx,ny,2], состоящий из двух двумерных размерности [nx,ny]. 
            // Первый(двумерный) содержит значения Ft в текущий момент времени,
            // а второй используется для рассчёта Ft в следующий момент.
            double[, ,] Ft = new double[nx, ny, 2]; // создание нового массива

            for (int i = 0; i < nx; i++) // инициализация массива 
                for (int j = 0; j < ny; j++) 
                {
                    Ft[i, 0, 0] = F0; // начальные условия
                    Ft[i, ny - 1, 0] = F0;
                    Ft[0, j, 0] = F0;
                    Ft[nx - 1, j, 0] = F0;
                };


            for (int m = 0; m < 100; m++) // вывод 100 кадров
            {
                //Команда Gnuplot, рисовать трехмерный график функции от двух аргументов(Ft(x,y)) в виде сетки. Мы задаем значения Ft в узлах сетки.
                Console.WriteLine("set pm3d hidden3d"); 
                //Команда Gnuplot, число ячеек сетки в доль осей OX и OY
                Console.WriteLine("splot [0:" + ny + "] [0:" + nx + "] \"-\" with lines");
                
                //Цикл:
                //"int i = 1" объявление переменной-счетчика, который будет учеличиваться на единицу "i++"
                //до тех пор пока не перестанет выплняться условие "i < nx"
                for (int i = 0; i < nx; i++) 
                {
                    for (int j = 0; j < ny; j++)
                    //Вывод значений Ft в узлах сетки, даные будуи использованы Gnuplot при рисовании
                        Console.WriteLine(Ft[i, j, 0]);
                    Console.WriteLine();
                };
                //Команда Gnuplot, отрисовать график
                Console.WriteLine("end");
                //Команда Gnuplot,  перед отрисовкой следующего графика подождать 0,05 секунды 
                Console.WriteLine("pause 0.05"); 

                //Циклы выполняют вычисление для всех узлов сетки кроме граничных(значение Ft в них считаем неизменным), поэтому i в пределах [1, nx-1] а не [0, nx]
                for (int i = 1; i < nx - 1; i++)
                    for (int j = 1; j < ny - 1; j++)
                        //Ft[i, j, 1] - значение Ft в i,j узле сетки в следующий момент времени, зависит от значений Ft в текущий момент так как указано ниже. 
                        //запись "/(double)4" это преобразование типов(по умолчанию числа типа int) и нужна чтобы исключить возможность ошибочного вычисления,
                        //т.к. компилятор может решить что деление на целое число нужно выполнитьь с отбрасыванием остатка.  
                        Ft[i, j, 1] = (Ft[i + 1, j, 0] + Ft[i - 1, j, 0] + Ft[i, j + 1, 0] + Ft[i, j - 1, 0]) / (double)4;

                //Циклы выполняют операцию для всех узлов сетки кроме граничных
                for (int i = 1; i < nx - 1; i++)
                    for (int j = 1; j < ny - 1; j++)
                        //На вывод отправляются значения Ft[i, j, 0], поэтому туда нужно скопировать рассчитанные значения для следующего момента времени Ft[i, j, 1]
                        Ft[i, j, 0] = Ft[i, j, 1];

            };
            
        }

    }
}